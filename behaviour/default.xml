<scxml 
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="initial_default">

	<script>
		function computeTDelta(oldEvent,newEvent){
			//summary:computes the offset between two events; to be later used with this.translate
			var dx = newEvent.clientX - oldEvent.clientX;
			var dy = newEvent.clientY - oldEvent.clientY;

			return {'dx':dx,'dy':dy};
		}
	</script>

	<datamodel>
		<data id="firstEvent"/>
		<data id="eventStamp"/>
		<data id="tDelta"/>

		<data id="controller"/>
		<data id="modules"/>
	</datamodel>

	<state id="initial_default">
		<transition event="init" target="idle">
			<assign location="controller" expr="_event.data.controller"/>
			<assign location="modules" expr="_event.data.modules"/>
		</transition>
	</state>

	<state id="idle">
		<transition event="mousedown" target="after_ctrl_mousedown_on_creator" 	
			cond="_event.data.domEvent.ctrlKey &amp;&amp; 
				_event.data.currentTarget.behaviours[modules.behaviours.CREATOR]">
		</transition>

		<!-- you can see here that there is an implicit understanding of priorities based on document order -->
		<transition event="mousedown" target="drawing_curve" 	
			cond="_event.data.domEvent.ctrlKey &amp;&amp; 
				_event.data.currentTarget.behaviours[modules.behaviours.ARROW_SOURCE]">
		</transition>

		<transition event="mousedown" target="dragging"
			cond="!(_event.data.domEvent.ctrlKey) &amp;&amp;
				_event.data.currentTarget.behaviours[modules.behaviours.DRAGGABLE]">
		</transition>

		<transition event="mousedown" target="editing_curve"
			cond="_event.data.currentTarget.behaviours[modules.behaviours.ARROW_EDITABLE]">
		</transition>

		<transition event="mousedown" 
			cond="_event.data.currentTarget.behaviours[modules.behaviours.TEXT_EDITABLE]">
			<script>
				var newText = prompt("Enter new text value:",_event.data.currentTarget.textContent);
				if(newText &amp;&amp; newText.length){
					_event.data.currentTarget.textContent = newText;
				}
				modules.requestLayout();
			</script>
		</transition>

	</state>

	<state id="editing_curve" initial="before_mousedown_on_control_point">
		<datamodel>
			<data id="curveBeingEdited"/>
			<data id="controlPointBeingDragged"/>
		</datamodel>

		<onentry>
			<assign location="curveBeingEdited" expr="_event.data.currentTarget"/>
			<script>
				curveBeingEdited.showControlPoints(); 
			</script>
		</onentry>

		<onexit>
			<script>
				curveBeingEdited.hideControlPoints(); 
			</script>
		</onexit>

		<state id="before_mousedown_on_control_point">
			<transition event="mousedown" target="dragging_control_point"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.CTRL_POINT_DRAG]">

				<assign location="controlPointBeingDragged" expr="_event.data.currentTarget"/>

			</transition>

			<!-- by default, mousdeown will just deselct -->
			<transition event="mousedown" target="idle"/>
			
		</state>

		<state id="dragging_control_point">
			<transition event="mouseup" target="before_mousedown_on_control_point"/>

			<transition event="mousemove">
				<script>
					controlPointBeingDragged.moveTo(_event.data.domEvent.clientX,_event.data.domEvent.clientY);
				</script>
			</transition>
		</state>

	</state>

	<state id="drawing_curve" initial="before_mouseover_arrow_target">
		<datamodel>
			<data id="curveBeingDrawn"/>
		</datamodel>

		<state id="before_mouseover_arrow_target" initial="selecting_initial_curve_drawing_mode">

			<transition event="esc" cond="!curveBeingDrawn.willPathBeEmptyAfterRemovingNextPoint()">
				<script>
					curveBeingDrawn.rollbackPoint();
				</script>
			</transition>

			<transition event="esc" target="idle" cond="curveBeingDrawn.willPathBeEmptyAfterRemovingNextPoint()">
				<script>
					curveBeingDrawn.remove();
				</script>
			</transition>
			
			<state id="selecting_initial_curve_drawing_mode">
				<onentry>
					<script>
						//create new line segment on the currentTarget
						curveBeingDrawn = modules.constructors.CurveIcon(_event.data.currentTarget);
						modules.requestLayout();
					</script>
				</onentry>

				<transition event="mousemove" target="updating_endpoint_before_dropping_quadratic"/>
				<transition event="mouseup" target="updating_endpoint_before_selecting_next_mode"/>
			</state>

			<state id="updating_endpoint_before_dropping_quadratic">
				<transition event="mousemove">
					<script>
						//update the arrow head
						//two-pixel off-set to prevent arrow from stealing events
						curveBeingDrawn.setEndPoint(_event.data.domEvent.clientX-2,_event.data.domEvent.clientY-2);
					</script>
				</transition>
				
				<transition event="mouseup" target="updating_endpoint_before_selecting_next_mode">
					<script>
						//convert the current line segment to a qudratic, with control point at these coordinates
						curveBeingDrawn.addControlPoint(_event.data.domEvent.clientX,_event.data.domEvent.clientY);
					</script>
				</transition>
			</state>

			<state id="updating_endpoint_before_selecting_next_mode">

				<transition target="after_mouseover_arrow_target" event="mouseover"
					cond="_event.data.currentTarget.behaviours[modules.behaviours.ARROW_TARGET]">
					<script>
						//snap to target
						curveBeingDrawn.setTarget(_event.data.currentTarget);
						modules.requestLayout();
					</script>
				</transition>

				<transition event="mousemove">
					<script>
						//update the arrow head
						//two-pixel off-set to prevent arrow from stealing events
						curveBeingDrawn.setEndPoint(_event.data.domEvent.clientX-2,_event.data.domEvent.clientY-2);
					</script>
				</transition>

				<transition event="mousedown" target="selecting_next_curve_drawing_mode"/>
			</state>

			<state id="selecting_next_curve_drawing_mode">
				<transition event="mouseup" target="updating_endpoint_before_selecting_next_mode">
					<script>
						//create a new line segment
						curveBeingDrawn.createNewLineSegment();
					</script>
				</transition>

				<transition event="mousemove" target="updating_prev_ctrl_point_before_dropping_quadratic">
					<script>
						//add ctrl point to current segment
						curveBeingDrawn.addControlPoint(_event.data.domEvent.clientX,_event.data.domEvent.clientY);
					</script>
				</transition>
			</state>

			<state id="updating_prev_ctrl_point_before_dropping_quadratic">
				<transition event="mousemove">
					<script>
						//update the last ctrl point on the current segment
						//FIXME: this will be in relation to his start point... or rather, the coordinates of mousedown in selecting_next_curve_drawing_mode. reflection, using that point as the origin
						curveBeingDrawn.setLastControlPoint(_event.data.domEvent.clientX,_event.data.domEvent.clientY,true);
					</script>
				</transition>

				<transition event="mouseup" target="updating_endpoint_before_selecting_next_mode">
					<script>
						//create a new quadratic
						curveBeingDrawn.createNewQuadraticSegment(
							_event.data.domEvent.clientX,
							_event.data.domEvent.clientY,
							_event.data.domEvent.clientX,
							_event.data.domEvent.clientY);
					</script>
				</transition>

			</state>

		</state>

		<state id="after_mouseover_arrow_target">
			<!-- TODO: probably want to add a style change to the drop target -->

			<!-- TODO: make sure that he's the same target before returning? -->
			<transition target="updating_endpoint_before_selecting_next_mode" event="mouseout"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.ARROW_TARGET]">
			</transition>

			<transition event="mousedown" target="idle"/>

		</state>
	</state>

	<state id="after_ctrl_mousedown_on_creator">
		<datamodel>
			<data id="creator"/>
		</datamodel>

		<onentry>
			<assign location="creator" expr="_event.data.currentTarget"/>
		</onentry>

		<transition target="idle" event="mouseup">
			<script>
				creator.create(_event.data.domEvent.clientX,_event.data.domEvent.clientY);
			</script>
		</transition>
	</state>

	<state id="dragging" initial="before_mouseover_drop_target">
		<datamodel>
			<data id="draggingEntity"/>
			<data id="draggingRect"/>
			<data id="dropTarget"/>
		</datamodel>

		<onentry>
			<assign location="draggingEntity" expr="_event.data.currentTarget"/>
			<assign location="firstEvent" expr="_event.data.domEvent"/>
			<assign location="eventStamp" expr="_event.data.domEvent"/>
			<script>
				var bbox = modules.svgHelper.getBBoxInCanvasSpace(draggingEntity);
				console.log(bbox);

				draggingRect = 	modules.svg.rect(bbox.x,bbox.y,bbox.width,bbox.height);
				draggingRect.id="dragging";

				console.log(draggingRect);

				firstEvent = evtStamp = _event.data.domEvent;
			</script>
		</onentry>

		<onexit>
			<script>
				//update the locations of the dragged entities 
				//TODO: make this all selected entities
				modules.svg.remove(draggingRect);

				tDelta = computeTDelta(firstEvent,_event.data.domEvent)

				//move group
				modules.svgHelper.translate(draggingEntity,tDelta.dx,tDelta.dy);

				modules.requestLayout();
			</script>
		</onexit>



		<!-- no target: this is a static reaction (targetless transition in SCXML parlance) -->
		<transition event="mousemove">
			<assign location="tDelta" expr="computeTDelta(eventStamp,_event.data.domEvent)"/>
			<script>
				modules.svgHelper.translate(draggingRect,tDelta.dx,tDelta.dy);
			</script>
			<assign location="eventStamp" expr="_event.data.domEvent"/>
		</transition>

		<state id="before_mouseover_drop_target">
			<onentry>	
				<log expr="'before_mouseover_drop_target'"/>
			</onentry>
	
			<transition target="after_mouseover_drop_target" event="mouseover"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.DROP_TARGET]
					&amp;&amp; !(draggingEntity.contains(_event.data.currentTarget) 
							|| _event.data.currentTarget.hasHierarchicalChild(draggingEntity))">
				<assign location="dropTarget" expr="_event.data.currentTarget"/>
			</transition>

			<transition event="mouseup" target="idle"/>
		</state>

		<state id="after_mouseover_drop_target">
			<onentry>	
				<log expr="'before_mouseover_drop_target'"/>
				<script>
					dropTarget.setHighlight();
				</script>
			</onentry>

			<onexit>
				<script>
					dropTarget.unsetHighlight();
				</script>
			</onexit>

			<transition target="before_mouseover_drop_target" event="mouseout"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.DROP_TARGET]">
			</transition>

			<transition event="mouseup" target="dummy_state_before_idle">
				<script>
					//set up constraint relationship
					dropTarget.dropShape(draggingEntity);
				</script>
			</transition>

		</state>

		<!-- this state is to prevent the exit action from firing before the transition action -->
		<state id="dummy_state_before_idle">
			<transition target="idle"/>
		</state>
	</state>

</scxml>
