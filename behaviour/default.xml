<scxml 
	xmlns="http://www.w3.org/2005/07/scxml"
	version="1.0"
	profile="ecmascript"
	initial="initial_default">

	<script>
		function computeTDelta(oldEvent,newEvent){
			//summary:computes the offset between two events; to be later used with this.translate
			var dx = newEvent.clientX - oldEvent.clientX;
			var dy = newEvent.clientY - oldEvent.clientY;

			return {'dx':dx,'dy':dy};
		}
	</script>

	<datamodel>
		<data id="firstEvent"/>
		<data id="eventStamp"/>
		<data id="tDelta"/>

		<data id="controller"/>
		<data id="modules"/>
	</datamodel>

	<state id="initial_default">
		<transition event="init" target="idle">
			<assign location="controller" expr="_event.data.controller"/>
			<assign location="modules" expr="_event.data.modules"/>
		</transition>
	</state>

	<state id="idle">
		<transition event="mousedown" target="after_ctrl_mousedown_on_creator" 	
			cond="_event.data.domEvent.ctrlKey &amp;&amp; 
				_event.data.currentTarget.behaviours[modules.behaviours.CREATOR]">
		</transition>

		<!-- you can see here that there is an implicit understanding of priorities based on document order -->
		<transition event="mousedown" target="drawing_curve" 	
			cond="_event.data.domEvent.ctrlKey &amp;&amp; 
				_event.data.currentTarget.behaviours[modules.behaviours.ARROW_SOURCE]">
		</transition>

		<transition event="mousedown" target="dragging"
			cond="_event.data.currentTarget.behaviours[modules.behaviours.DRAGGABLE]">
		</transition>

	</state>

	<state id="drawing_curve" initial="before_mouseover_drop_target">
		<datamodel>
			<data id="curveBeingDrawn"/>
		</datamodel>

		<onentry>
			<script>
				//create a new curve on the currentTarget
				curveBeingDrawn = modules.constructors.CurveIcon(_event.data.currentTarget);
			</script>
		</onentry>
	
		<!-- normally we would roll back points here, but because we assume he's a line, we just delete it and return to idle.
			other stuff will have more sophisticated behaviour involving rolling back points -->
		<transition event="esc" target="idle">
			<script>
				curveBeingDrawn.remove();
			</script>
		</transition>

		<transition event="mousemove">
			<script>
				//update the arrow head
				//two-pixel off-set to prevent arrow from stealing events
				curveBeingDrawn.setEndPoint(_event.data.domEvent.clientX-2,_event.data.domEvent.clientY-2);
			</script>
		</transition>

		<state id="before_mouseover_drop_target">

			<transition target="after_mouseover_drop_target" event="mouseover"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.ARROW_TARGET]"/>

		</state>

		<state id="after_mouseover_drop_target">
			<!-- TODO: probably want to add a style change to the drop target -->

			<!-- TODO: make sure that he's the same target before returning? -->
			<transition target="before_mouseover_drop_target" event="mouseout"
				cond="_event.data.currentTarget.behaviours[modules.behaviours.ARROW_TARGET]"/>

			<transition event="mousedown" target="idle">
			
				<script>
					//set the arrow target
					curveBeingDrawn.setTarget(_event.data.currentTarget);
				</script>
				
			</transition>

		</state>
	</state>

	<state id="after_ctrl_mousedown_on_creator">
		<transition target="idle" event="mouseup">
			<script>
				//this will be changed to create whatever the radio buttons point to
				modules.constructors.ClassIcon(_event.data.domEvent.clientX,_event.data.domEvent.clientY);
			</script>
		</transition>
	</state>

	<state id="dragging">
		<datamodel>
			<data id="draggingEntity"/>
			<data id="draggingRect"/>
		</datamodel>

		<onentry>
			<assign location="draggingEntity" expr="_event.data.currentTarget"/>
			<assign location="firstEvent" expr="_event.data.domEvent"/>
			<assign location="eventStamp" expr="_event.data.domEvent"/>
			<script>
				var bbox = modules.svgHelper.getBBoxInCanvasSpace(draggingEntity);
				console.log(bbox);

				draggingRect = 	modules.svg.rect(bbox.x,bbox.y,bbox.width,bbox.height);
				draggingRect.id="dragging";

				console.log(draggingRect);

				firstEvent = evtStamp = _event.data.domEvent;
			</script>
		</onentry>

		<onexit>
			<script>
				//update the locations of the dragged entities 
				//TODO: make this all selected entities
				modules.svg.remove(draggingRect);

				tDelta = computeTDelta(firstEvent,_event.data.domEvent)

				//move group
				modules.svgHelper.translate(draggingEntity,tDelta.dx,tDelta.dy);

				modules.requestLayout();
			</script>
		</onexit>


		<transition event="mouseup" target="idle"/>

		<!-- no target: this is a static reaction (targetless transition in SCXML parlance) -->
		<transition event="mousemove">
			<assign location="tDelta" expr="computeTDelta(eventStamp,_event.data.domEvent)"/>
			<script>
				modules.svgHelper.translate(draggingRect,tDelta.dx,tDelta.dy);
			</script>
			<assign location="eventStamp" expr="_event.data.domEvent"/>
		</transition>
	</state>

</scxml>
